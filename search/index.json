[{"content":"初期設定 1 2 3 4 $ brew install fish $ which fish /opt/homebrew/bin/fish $ sudo vim /etc/shells /etc/shells\n1 2 3 4 5 6 7 8 /bin/bash /bin/csh /bin/dash /bin/ksh /bin/sh /bin/tcsh /bin/zsh /opt/homebrew/bin/fish 1 $ chsh -s /opt/homebrew/bin/fish ターミナル再起動\nHomebrew インストール 1 /bin/bash -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\u0026#34; ~/.config/fish/config.fish に、PATH を通すためのコマンドを追加 fish 起動時に実行されるもの。\nconfig.fish\n1 2 3 if status is-interactive eval (/opt/homebrew/bin/brew shellenv) end ターミナルを再起動\nStarship インストール 1 $ brew install starship starship init fish | source を ~/.config/fish/config.fishに追加\nfisher インストール 1 curl -sL https://git.io/fisher | source \u0026amp;\u0026amp; fisher install jorgebucaran/fisher color theme 変更 https://github.com/Jomik/fish-gruvbox\n1 fisher install jomik/fish-gruvbox theme_gruvbox dark hard を ~/.config/fish/config.fishに追加\nVSCode の shell を fish に変更 setting.json\n1 2 3 4 5 6 7 8 9 { \u0026#34;terminal.integrated.profiles.osx\u0026#34;: { \u0026#34;fish\u0026#34;: { \u0026#34;path\u0026#34;: \u0026#34;/opt/homebrew/bin/fish\u0026#34;, \u0026#34;args\u0026#34;: [\u0026#34;-l\u0026#34;] } }, \u0026#34;terminal.integrated.defaultProfile.osx\u0026#34;: \u0026#34;fish\u0026#34; } lazyvim https://www.lazyvim.org/installation\n最終的な ~/.config/fish/config.fish\n1 2 3 4 5 6 7 8 9 if status is-interactive eval (/opt/homebrew/bin/brew shellenv) end starship init fish | source theme_gruvbox dark hard alias vim=\u0026#34;nvim\u0026#34; ","date":"2024-11-06T00:00:00Z","permalink":"https://sskdev.jp/p/20241106/","title":"zsh から fish に乗り換えた"},{"content":"Spring Initializr でプロジェクト作成 https://start.spring.io/\nとりあえずこれで作成して、必要になった Dependencies は後から付け足します。\nダウンロードしたプロジェクトを Java や Kotlin と相性がいい IntelliJ IDEA で開きます。 無料版として IntelliJ IDEA Community Edition もあるので、今回はこちらを使います。\nhttps://www.jetbrains.com/ja-jp/idea/download/?section=mac\n作成されたパッケージを開くとこんな感じです。resources 配下に graphql パッケージが作成されていますね。 ここに schema ファイルを保存するみたいです。\n今回はざっくりこんな構成で行きます。\nパッケージ構成・アーキテクチャ オニオンアーキテクチャ風で行きたいと思います。\ncom.example.demo 配下\npresentation Controller クラス や Request/Response 用の DTO を置くところ application Application Service クラス を置くところ domain エンティティや Domain Service クラスを置くところ infrastructure Repository クラスなど DB や外部プラットフォームと繋ぐところ 初期設定 application.propertiesファイルをapplication.yml ファイルに変更します。 別にどっちでもいいのですが、私が yml の方が慣れているので変更しておきます。\nspring.graphql.path はこの API のエンドポイント graphiql というのは開発ツールです。これだけで使えて簡単なので enabled を true にしておきます。\n1 2 3 4 5 6 7 spring: application: name: demo graphql: path: /graphql graphiql: enabled: true GraphQL が叩けることを確認 まずは GraphQL が叩けることを確認しましょう。\nresources/graphql配下に schema.grahqlsファイルを作成してください。 今回は Post というユーザーが投稿した程のものを表示させるための実装を行います。\n1 2 3 4 5 6 7 8 type Query { posts: [Post!]! } type Post { id: Int! content: String! } Controller から返してみる domain パッケージに model パッケージを作成して、その中にPost.ktを作成します。\n1 2 3 4 data class Post( val id: Int, val content: Int ) presentation パッケージに controller パッケージを追加しPostController.ktを作成します。 この中にpostsというメソッドを作成します。このメソッドと schema.graphqls に書いたクエリを紐づけるわけですね。\n紐づけるためには@QueryMappingというアノテーションを追加します。なんとこれだけで紐づきます。簡単ですね。\n1 2 3 4 5 6 @Controller class PostController() { @QueryMapping fun posts(): List\u0026lt;Post\u0026gt; = [Post(1, \u0026#34;投稿1\u0026#34;), Post(2, \u0026#34;投稿2\u0026#34;)] } 続く\n","date":"2024-11-05T00:00:00Z","permalink":"https://sskdev.jp/p/20241105/","title":"Kotlin と Spring Boot で GraphQL に入門"},{"content":"Swift の Sendable は、簡単に言うと「安全にスレッド間でやりとりできる型」を示すプロトコルです。マルチスレッドプログラム、つまり複数のスレッドが同時に動作するプログラムで使うときに役立ちます。\nなぜ Sendable が必要なのか？ Swift は UI を扱うこともあり、マルチスレッドを強く意識しなければなりません。 マルチスレッドでのプログラミングでは、複数のスレッドが同時に同じデータにアクセスして操作することで、予期しないバグやエラーが発生することがあります。こういったバグを避けるために「このデータはスレッド間で安全に扱える」と明示する仕組みが必要です。これが Sendable の役割です。\n具体的にはどういうこと？ Sendable を使うと、Swift が「この型はスレッド間で安全に送れる」と判断してくれます。たとえば、Int や String のような基本型はスレッド間で安全にやりとりできますが、複雑なデータ構造や、スレッドセーフでない型はそうとは限りません。Sendable を型に適用することで、その型がスレッドセーフかどうかをコンパイラがチェックしてくれるようになります。\nSendable は基本的にマーカープロトコルのため、それ自体が何かするということはありません。ただ、安全に送信できることを示すものです。\nSendable の使い方 具体的には、独自の型を作成するときに、その型が Sendable を満たしているかを宣言できます。たとえば以下のように使います。\n1 2 3 struct Data: Sendable { let value: Int } 上記のコードでは、MyData が Sendable プロトコルに準拠しているため、この型のインスタンスはスレッド間で安全にやりとりできます。\nSwift で struct が Sendable プロトコルに準拠するためには、以下の条件を満たす必要があります。\nSendable に準拠している例 Sendable な struct の例 1 2 3 4 5 struct UserProfile: Sendable { let id: Int // IntはSendable let name: String // StringもSendable let isActive: Bool // BoolもSendable } この UserProfile 構造体は、全てのプロパティが Sendable 準拠の型なので、Sendable に自動で準拠しています。\nSendable な class の例 1 2 3 4 5 6 7 8 9 final class UserSettings: Sendable { let theme: String // StringはSendable let notificationsEnabled: Bool // BoolもSendable init(theme: String, notificationsEnabled: Bool) { self.theme = theme self.notificationsEnabled = notificationsEnabled } } Sendable ではない struct の例 1 2 3 4 struct NonSendableStruct { var id: Int var data: [String: Any] // AnyはSendableではない } 1 2 3 4 5 6 7 class NonSendableClass { var count: Int = 0 // varで可変プロパティ var closure: (() -\u0026gt; Void)? // クロージャもSendableではない func increment() { count += 1 } } この NonSendableClass は、Sendable に準拠できません。理由は以下のとおりです：\n• count が var で宣言されているため、状態が変更される可能性があります。 • closure プロパティがクロージャ型で、これはスレッドセーフでない可能性があるためです。\n@unchecked Sendable を使った例 一部のプロパティがスレッドセーフでない場合や、スレッドセーフであることを自己責任で保証できる場合には、@unchecked Sendable を使うことができます。\n@unchecked Sendable を使用した struct の例 1 2 3 4 struct MyStruct: @unchecked Sendable { var name: String var cache: [String: Any] // AnyはSendableではないが、スレッドセーフを保証したい } ここで、cache プロパティに Any 型を使っていますが、@unchecked Sendable を使うことで Sendable として扱えるようになります。ただし、この場合はスレッドセーフを保証する責任がプログラマ側にあるため、慎重に設計する必要があります。\n1 2 3 4 5 6 7 8 final class MyClass: @unchecked Sendable { var count: Int = 0 var settings: [String: String] = [:] func updateCount() { count += 1 } } ","date":"2024-11-04T00:00:00Z","permalink":"https://sskdev.jp/p/20241104/","title":"SwiftのSendableとは何ですか？"}]